No listed session skill applies here, so this is a direct implementation blueprint.

**1) Project shape (pure engine + Android View)**
- `:engine` (pure Kotlin, no Android imports)
- `:app` (Android Activity, custom `View`, input/render loop, save adapter)

Use this direction:
- `GameEngine` owns deterministic state + systems.
- `GameView` only renders `RenderSnapshot` and sends `GameIntent`.
- `MainActivity` wires loop + persistence lifecycle.

```kotlin
// engine/core/GameEngine.kt
class GameEngine(
    private val world: WorldState,
    private val dayNight: DayNightCycle,
    private val interaction: InteractionSystem,
    private val crafting: CraftingSystem,
    private val mobSystem: MobSystem,
    private val shelterEval: ShelterSafetyEvaluator,
    private val progression: ProgressionSystem
) {
    fun tick(deltaSec: Float, intents: List<GameIntent>): EngineFrameResult { /* ... */ TODO() }
}
```

**2) Day/Night cycle**
```kotlin
enum class DayPhase { DAWN, DAY, DUSK, NIGHT }

data class DayNightState(
    val time01: Float,          // 0f..1f
    val dayIndex: Int,
    val phase: DayPhase,
    val ambientLight: Float     // 0f..1f
)

class DayNightCycle(private val secondsPerDay: Float = 300f) {
    private var elapsed = 0f
    fun tick(deltaSec: Float): DayNightState {
        elapsed += deltaSec
        val dayIndex = (elapsed / secondsPerDay).toInt()
        val t = (elapsed % secondsPerDay) / secondsPerDay
        val phase = when {
            t < 0.20f -> DayPhase.DAWN
            t < 0.55f -> DayPhase.DAY
            t < 0.75f -> DayPhase.DUSK
            else -> DayPhase.NIGHT
        }
        val light = when (phase) {
            DayPhase.DAY -> 1f
            DayPhase.NIGHT -> 0.2f
            DayPhase.DAWN, DayPhase.DUSK -> 0.6f
        }
        return DayNightState(t, dayIndex, phase, light)
    }
}
```

**3) Mine/Place system**
```kotlin
data class TilePos(val x: Int, val y: Int)
enum class BlockType { AIR, DIRT, STONE, WOOD, TORCH, WALL, DOOR }

sealed class MineResult { object Fail : MineResult(); data class Success(val drops: List<ItemStack>) : MineResult() }
sealed class PlaceResult { object Fail : PlaceResult(); object Success : PlaceResult() }

class InteractionSystem(
    private val maxReach: Int = 4,
    private val dropTable: DropTable
) {
    fun mine(world: WorldState, player: PlayerState, target: TilePos): MineResult { /* rules + drops */ TODO() }
    fun place(world: WorldState, player: PlayerState, target: TilePos, block: BlockType): PlaceResult { /* validate */ TODO() }
}
```

Rules for MVP:
- Mine: in reach, not `AIR`, block hardness <= tool tier.
- Place: in reach, target is `AIR`, player inventory has block item, cannot trap player in solid tile.

**4) Crafting (3-5 recipes)**
```kotlin
enum class ItemId { LOG, PLANK, STICK, COAL, WOOD_PICKAXE, TORCH, WOOL, BED }

data class ItemStack(val item: ItemId, val count: Int)
data class Recipe(
    val id: String,
    val inputs: Map<ItemId, Int>,
    val outputs: List<ItemStack>,
    val unlockLevel: Int = 1
)

object StarterRecipes {
    val all = listOf(
        Recipe("planks", mapOf(ItemId.LOG to 1), listOf(ItemStack(ItemId.PLANK, 4))),
        Recipe("sticks", mapOf(ItemId.PLANK to 2), listOf(ItemStack(ItemId.STICK, 4))),
        Recipe("wood_pickaxe", mapOf(ItemId.PLANK to 3, ItemId.STICK to 2), listOf(ItemStack(ItemId.WOOD_PICKAXE, 1))),
        Recipe("torch", mapOf(ItemId.COAL to 1, ItemId.STICK to 1), listOf(ItemStack(ItemId.TORCH, 4))),
        Recipe("bed", mapOf(ItemId.WOOL to 3, ItemId.PLANK to 3), listOf(ItemStack(ItemId.BED, 1)), unlockLevel = 2)
    )
}

class CraftingSystem(private val recipes: List<Recipe>) {
    fun craft(recipeId: String, inv: Inventory, progression: ProgressionState): Boolean { /* consume/add */ TODO() }
}
```

**5) Mob archetypes (friendly/chaser/boss-event)**
```kotlin
enum class MobType { BUTTERFLY, SLIME, NIGHT_TITAN }

data class MobState(
    val id: Long,
    val type: MobType,
    var hp: Int,
    var pos: Vec2,
    var target: Vec2? = null
)

interface MobBrain {
    fun tick(ctx: MobContext, mob: MobState): MobCommand
}

class FriendlyBrain : MobBrain { override fun tick(ctx: MobContext, mob: MobState) = MobCommand.Wander }
class ChaserBrain : MobBrain { override fun tick(ctx: MobContext, mob: MobState) = MobCommand.ChasePlayer }
class BossEventBrain : MobBrain { override fun tick(ctx: MobContext, mob: MobState) = MobCommand.BossPattern }

class MobSystem(
    private val brains: Map<MobType, MobBrain>,
    private val rng: RandomSource
) {
    fun update(ctx: MobContext) { /* spawn + ai + despawn */ }
}
```

Spawn policy:
- Friendly: day-biased, near grass.
- Chaser: dusk/night, outside shelter radius.
- Boss event: once every N nights or progression trigger (`level >= 3 && dayPhase == NIGHT`).

**6) Shelter safety score**
```kotlin
enum class SafetyBand { DANGER, RISKY, SAFE }

data class ShelterSafetyScore(
    val total: Int,          // 0..100
    val roofCoverage: Int,
    val enclosure: Int,
    val light: Int,
    val doorBonus: Int,
    val band: SafetyBand
)

class ShelterSafetyEvaluator {
    fun evaluate(world: WorldState, playerTile: TilePos, phase: DayPhase): ShelterSafetyScore {
        // sample weighting: roof 35, enclosure 35, light 20, door 10
        TODO()
    }
}
```

Use score effects:
- `SAFE (>=70)`: no chaser spawn in 8-tile radius.
- `RISKY (40..69)`: normal spawn.
- `DANGER (<40)`: increased night spawn chance.

**7) Progression + local save**
```kotlin
@kotlinx.serialization.Serializable
data class ProgressionState(
    val level: Int = 1,
    val xp: Int = 0,
    val nightsSurvived: Int = 0,
    val bossesDefeated: Int = 0,
    val unlockedRecipeIds: Set<String> = setOf("planks", "sticks")
)

@kotlinx.serialization.Serializable
data class GameSave(
    val world: WorldStateSnapshot,
    val player: PlayerSnapshot,
    val progression: ProgressionState,
    val dayNight: DayNightSnapshot,
    val version: Int = 1
)

interface SaveRepository {
    suspend fun save(slot: Int, data: GameSave)
    suspend fun load(slot: Int): GameSave?
}

class ProgressionSystem {
    fun onMineBlock(state: ProgressionState): ProgressionState = TODO()
    fun onCraft(state: ProgressionState, recipeId: String): ProgressionState = TODO()
    fun onNightEnd(state: ProgressionState): ProgressionState = TODO()
}
```

Android adapter:
- `FileSaveRepository(context.filesDir)` with `kotlinx.serialization.json.Json`.
- Autosave every 20-30s and on `onPause`.

**8) Custom View wiring (MVP loop)**
```kotlin
class GameView(context: Context, attrs: AttributeSet?) : View(context, attrs) {
    var latest: RenderSnapshot = RenderSnapshot.EMPTY
    private val intents = ArrayDeque<GameIntent>()

    fun consumeIntents(): List<GameIntent> = buildList { while (intents.isNotEmpty()) add(intents.removeFirst()) }

    override fun onTouchEvent(event: MotionEvent): Boolean { /* map gesture -> intent */ return true }
    override fun onDraw(canvas: Canvas) { /* draw tiles + mobs + hud */ }
}
```

`MainActivity`:
- fixed timestep update (e.g. 20 TPS) + render each frame.
- call `engine.tick(dt, gameView.consumeIntents())`.
- assign returned snapshot to view and `invalidate()`.

**9) Unit-test strategy (engine-only, fast)**
- `world`: mine/place bounds, reach checks, solid collision, drop correctness.
- `crafting`: valid craft, insufficient inputs, locked recipe, repeated craft.
- `mob`: friendly never emits attack command, chaser acquires player target, boss spawns only when trigger met.
- `dayNight`: phase boundaries and wrap from end-of-day to dawn.
- `shelter`: score thresholds and spawn modifier mapping.

Test setup recommendations:
- deterministic `RandomSource(seed=123)`.
- tiny fixture maps (`16x16`) with builder helpers.
- table-driven tests for recipe and shelter cases.
- keep all logic tests in `:engine` with JUnit; no Android instrumentation needed for these systems.

If you want, I can convert this into an actual starter folder structure with compile-ready Kotlin files next.